<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- mathJax -->
    <script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <!-- font awesome -->
    <script src="https://use.fontawesome.com/9ce831b1c5.js"></script>
    <link rel="icon" type="image/x-icon" href="/photos/cs-tree.jpg">
    <title>Project 3</title>
    
</head>
<body>
    <div class="title-of-webpage">
        <h1>Project 3</h1>
        <h2>Path Planning</h2>
        <h6>Written by Bryan Li and Michael Dick</h6>    
    </div>
    <div class="description">
        <p>
            Have you ever wondered how a robot gets from point <math><mi>A</mi></math> to a point <math><mi>B</mi></math>? This project answers that question.
            <br> <br>
            In this project, we explore the idea breadth first search. First, the lidar scans an area turning that area into grid it can represent mathematically. Second, the lidar sees each grid and puts the coordinates into a queue we have written up in C++. In this algorithm we pop a coordinate from the queue, check this coordinates' neighbors, and see if they have been discovered. If these neighbors have not been discovered then we add them to our queue. We repeat this process until we find our goal. We return this path to our robot and then the robot will drive this path.
            <br><br>
            Breadth first search (BFS) is a greedy algorithm and will find the shortest path from the starting node to the next node it is looking for. Since this is a greedy algorithm, it is not guaranteed to be the optimal solution, it only makes the best decision locally. A disadvantage for BFS is that it makes discussion locally, which is great for smaller areas, but when it comes to larger areas it may take longer. Also, all of the nodes need to be stored which can take up quite a bit of memory.
            <br><br>
            BFS always finds the shortest path locally, but not always the shortest path in the grand scheme. A-star on the other hand is guaranteed to return the shortest path because it uses path cost to determine if its a good path to take. Thus, A-star makes decision on what path is the quickest to the goal.
        </p>
    </div>
    <div class="description">
        <p align = "center">
            Below is an example using BFS on <code>map 1</code>.
            <img class = "maps"src="/photos/map1.png" alt="map-1">
        </p>
    </div>
    <div class="description">
        <p align = "center">
            This is <code>map 3</code> running our BFS algorithm.
            <img class = "maps"src="/photos/map3.png" alt="map-1">
        </p>
    </div>
    <div class="description">
        <p align = "center">
            This is <code>map 4</code> running our BFS algorithm.
            <img class = "maps"src="/photos/map4.png" alt="map-1">
        </p>
    </div>
    <div class="description">
        <p>
            Placeholder for video an image of robot's path for maze.
        </p>
    </div>
    <div class="description">
        <p>
            Placeholder for video an video of robot's path for maze.
        </p>
    </div>
    <!-- <footer>
        <a href="https://github.com/bli76/bli76.github.io">
        <img src="github.svg" alt="">
    </a>
    </footer> -->
    <div class="buffer"></div>
</body>
</html>